import { CanvasObject } from "./CanvasObject.js";
import { Counter } from "./Counter.js";
import { Ball } from "./Ball.js";
import { Player } from "./Player.js";
import { Floating } from "./Floating.js";
"use strict";

class Game {
/**
 * @param {JSON array} objs array generated by parsing the JSON with the config file
 */
constructor(objs) {	
	// TODO: para el que va a entrar, en la config tendra que estar el room_name
	this.canvas = document.getElementById("pong");
	this.context = this.canvas.getContext("2d");
	this.game_objects = [];

	this.background_color = "black";
	this.object_color = "white";
	this.timeout = 60000;
	this.max_score = 5;

	this.websocket_queue = '';

	for (let i in objs) {
		switch (objs[i].type) {
		case "config":
			for(let j in objs[i])
				this[j] = objs[i][j];
			break;
		case "player":
			this.game_objects.push(new Player(objs[i], this.canvas, this.context));
			break;
		case "ball":
			this.game_objects.push(new Ball(objs[i], this.canvas, this.context));
			break;
		case "counter":
			this.game_objects.push(new Counter(objs[i], this.canvas, this.context));
			break;
		case "floating":
			this.game_objects.push(new Floating(objs[i], this.canvas, this.context));
			break;
		default:
			this.game_objects.push(new CanvasObject(objs[i], this.canvas, this.context));
		}
	}

	let tmp = this.game_objects.findIndex((obj) => obj.type === "counter")
	this.counter = this.game_objects[tmp];
	this.game_objects[tmp].timeout = this.timeout;

	for (let i in this.game_objects) {
		if (this.game_objects[i].type === "ball")
			this.game_objects[i].counter = this.game_objects[tmp];
	}

	// TODO: sacar color jugadores 1 y 2. Que cada jugador pueda jugar con los colores que desee
	// esto no iria en el json que genera la sala?
}

async setWebSocket() {
	return new Promise((resolve, reject) => {
		this.websocket = new WebSocket(
			'wss://'
			+ window.location.hostname
			+ ":7000"
			+ '/ws/pong/'
			+ this.room_name
			+ '/'
		)
		this.websocket.onopen = () => {
			console.log(`WebSocket opened`);

			getUsers(localStorage.getItem("token")).then((user) => {
				this.user_id = user.id;
				this.websocket.send(JSON.stringify({
					"message": {
						"id": user.id,
						"player1_selected": false,
						"room_ready": false
					}
				}));
			});
		}

		this.websocket.onclose = () => {
			console.log(`WebSocket closed`);
		}

		this.websocket.onmessage = (event) => {
			const data = JSON.parse(event["data"]);

			getUsers(localStorage.getItem("token")).then(user => {
				if (data["message"]["id"] === user.id)
					return;

				if (data["message"]["room_ready"]) {
					this.game_objects.find((obj) => obj.id === "player2").pk = data["message"]["player2_id"];

					this.game_objects.find((obj) => obj.id === "player2").move_up = '';
					this.game_objects.find((obj) => obj.id === "player2").move_down = '';

					this.websocket.onmessage = (event) => {
						const data = JSON.parse(event["data"]);
						this.websocket_queue = data["message"];
					}

					resolve();
					return; // TODO: es necesario?, hay otro abajo
				}

				if (data["message"]["player1_selected"] === true) {
					this.game_objects.find((obj) => obj.id === "player1").pk = data["message"]["player1_id"];

					this.game_objects.find((obj) => obj.id === "player2").pk = user.id;

					// TODO: guarrada, pero funciona
					this.game_objects.find((obj) => obj.id === "player1").move_up = '';
					this.game_objects.find((obj) => obj.id === "player1").move_down = '';

					this.websocket.send(JSON.stringify({
						"message": {
							"id": user.id,
							"player2_id": user.id,
							"player1_selected": false,
							"room_ready": true	
						}
					}));

					this.websocket.onmessage = (event) => {
						const data = JSON.parse(event["data"]);
						this.websocket_queue = data["message"];
					}

					resolve();
					return;
				}

				this.game_objects.find((obj) => obj.id === "player1").pk = user.id;
				
				this.websocket.send(JSON.stringify({
					"message": {
						"id": user.id,
						"player1_id": user.id,
						"player1_selected": true
					}
				}));

			});
		}

		setTimeout(() => {
			reject();
		}, 500000);
	})
}

/**
 * @brief clears all the canvas to get only the background
 */
drawBackground() {
	// Clear the canvas
	this.context.fillStyle = this.background_color;
	this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

	// Draw the center line
	this.context.beginPath();
	this.context.strokeStyle = this.counter.color;
	this.context.lineWidth = "2";
	this.context.moveTo(this.canvas.width / 2, this.canvas.height / 8);
	this.context.lineTo(this.canvas.width / 2, this.canvas.height);
	this.context.moveTo(0, this.canvas.height / 8);
	this.context.lineTo(this.canvas.width, this.canvas.height / 8);
	this.context.closePath();
	this.context.stroke();
}

/**
 * @returns true if game has reached any end condition, false otherwise
 */
isEnd() {
	if (this.counter.time_passed >= this.timeout)
		return true;

	if (this.counter.highest_score >= this.max_score)
		return true;

	return false;
}

/**
 * @brief game loop
 */
gameLoop() {
	let animation;

	this.websocket.send(JSON.stringify({
		type: "direction",
		message: {
			room_id: this.room_id,
			player: this.playerN,
			dir: this.dir
		}
	}));

	this.render(this.game_state);

	if (!this.isEnd())// TODO: que sea el server quien mande que la partida ha terminado
		animation = window.requestAnimationFrame(this.gameLoop.bind(this));
	else {
		this.websocket.close();
		console.log(JSON.stringify(this)); // TODO: exportar info de la partida
		window.cancelAnimationFrame(animation);
	}
}

render(game_state) {
	const objs = JSON.parse(game_state);

	this.drawBackground();
	for (let i in objs) {
		switch (objs[i].type) {
		case "player":
			(new Player(objs[i], this.canvas, this.context)).render();
			break;

		case "ball":
			(new Ball(objs[i], this.canvas, this.context)).render();
			break;

		case "counter":
			(new Counter(objs[i], this.canvas, this.context)).render();
			break;

		default:
			(new CanvasObject(objs[i], this.canvas, this.context)).render();
		}
	}
}

createRoom() {
// getUsers(localStorage.getItem("token")).then(user => {}) // TODO: para setear las salas
	self.room_name = self.generateRandomString(16);
	self.playerN = "player1";

	this.websocket = new WebSocket(
		'wss://'
		+ window.location.hostname
		+ ":7000"
		+ '/ws/pong/'
		+ this.room_name
		+ '/'
	)

	this.websocket.onopen = () => {
		console.log(`WebSocket closed`);

		// identificarse
		this.websocket.send(JSON.stringify({
			type: "identify",
			message: {
				user_id: this.pk
			}
		}));

		// TODO: crear la sala
		this.websocket.send(JSON.stringify({
			type: "create.room",
			message: {
				// TODO: la configuracion de la partida donde estaba?
			}
		}));

	}

	this.websocket.onclose = () => {
		console.log(`WebSocket closed`);
	}

	this.websocket.onmessage = (event) => {
		const data = JSON.parse(event["data"]);

		switch(data["type"]) {
			case "game.state":
				self.game_state = data["message"];
				break;
		
			case "room.created":
				self.room_id = data["message"]["room_id"]
				alert(`DEBUG: room_id: ${room_id}`)
				break;
		
			case "game.start":
				alert(`room ${self.room_id} has started`)
				// TODO: que tendria que hacer?
				break;
			}
	}
}

joinRoom() {}


setStartTime(time) {
	this.game_objects.find((obj) => obj.id === "counter").setStartTime(time);
}

toJSON() {
	// TODO: definir bien el JSON que posteriormente se serializara
	// TODO: id del torneo
	// TODO: bool de si esta dentro de un torneo
	return {
		player1_pk: this.game_objects.find((obj) => obj.id === "player1").pk,
		player1_score: this.counter.player1_score,

		player2_pk: this.game_objects.find((obj) => obj.id === "player2").pk,
		player2_score: this.counter.player2_score,

		game_time: this.counter.time_passed
	}
}

generateRandomString(length) {
	let result = '';
	const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

	const charactersLength = characters.length;

	for (let i = 0; i < length; i++) {
		result += characters[Math.floor(Math.random() * charactersLength)];
	}

	return result;
}
}

export {Game}

function event_handler(event) {
	const data = JSON.parse(event["data"]);

	switch(data["type"]) {
	case "game.state":
		self.game_state = data["message"];
		break;

	case "room.created":
		self.room_id = data["message"]["room_id"]
		alert(`DEBUG: room_id: ${room_id}`)
		break;

	case "game.start":
		alert(`room ${self.room_id} has started`)
		// TODO: que tendria que hacer?
		break;
	}
}

