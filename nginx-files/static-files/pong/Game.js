import { CanvasObject } from "./CanvasObject.js";
import { Counter } from "./Counter.js";
import { Ball } from "./Ball.js";
import { Player } from "./Player.js";
import { Floating } from "./Floating.js";
"use strict";

class Game {
/**
 * @param {JSON array} objs array generated by parsing the JSON with the config file
 */
constructor(objs) {	
	this.canvas = document.getElementById("pong");
	this.context = this.canvas.getContext("2d");
	this.game_objects = [];

	this.background_color = "black";
	this.object_color = "white";
	this.timeout = 60000;
	this.max_score = 5;

	this.websocket_queue = '';

	for (let i in objs) {
		switch (objs[i].type) {
		case "config":
			for(let j in objs[i])
				this[j] = objs[i][j];
			break;
		case "player":
			this.game_objects.push(new Player(objs[i], this.canvas, this.context));
			break;
		case "ball":
			this.game_objects.push(new Ball(objs[i], this.canvas, this.context));
			break;
		case "counter":
			this.game_objects.push(new Counter(objs[i], this.canvas, this.context));
			break;
		case "floating":
			this.game_objects.push(new Floating(objs[i], this.canvas, this.context));
			break;
		default:
			this.game_objects.push(new CanvasObject(objs[i], this.canvas, this.context));
		}
	}

	let tmp = this.game_objects.findIndex((obj) => obj.type === "counter")
	this.counter = this.game_objects[tmp];
	this.game_objects[tmp].timeout = this.timeout;

	for (let i in this.game_objects) {
		if (this.game_objects[i].type === "ball")
			this.game_objects[i].counter = this.game_objects[tmp];
	}

	// TODO: sacar color jugadores 1 y 2. Que cada jugador pueda jugar con los colores que desee
	// esto no iria en el json que genera la sala?
}

async setWebSocket() {
	return new Promise((resolve, reject) => {
		this.websocket_queue = '';

		this.websocket = new WebSocket(
			'wss://'
			+ window.location.hostname
			+ ":7000"
			+ '/ws/pong/'
			+ this.room_name
			+ '/'
		)
		this.websocket.onopen = () => {
			console.log(`WebSocket opened`);

			getUsers(localStorage.getItem("token")).then((user) => {
				this.user_id = user.id;
				this.websocket.send(JSON.stringify({
					"message": {
						"id": user.id,
						"player1_selected": false,
						"room_ready": false
					}
				}));
			});
		}

		this.websocket.onclose = () => {
			console.log(`WebSocket closed`);
		}

		this.websocket.onmessage = (event) => {
			const data = JSON.parse(event["data"]);

			getUsers(localStorage.getItem("token")).then(user => {
				if (data["message"]["id"] === user.id)
					return;

				if (data["message"]["room_ready"]) {
					this.game_objects.find((obj) => obj.id === "player2").pk = data["message"]["player2_id"];

					this.game_objects.find((obj) => obj.id === "player2").move_up = '';
					this.game_objects.find((obj) => obj.id === "player2").move_down = '';

					this.websocket.onmessage = (event) => {
						const data = JSON.parse(event["data"]);
						this.websocket_queue = data["message"];
					}

					resolve();
					return; // TODO: es necesario?, hay otro abajo
				}

				if (data["message"]["player1_selected"] === true) {
					this.game_objects.find((obj) => obj.id === "player1").pk = data["message"]["player1_id"];

					this.game_objects.find((obj) => obj.id === "player2").pk = user.id;

					// TODO: guarrada, pero funciona
					this.game_objects.find((obj) => obj.id === "player1").move_up = '';
					this.game_objects.find((obj) => obj.id === "player1").move_down = '';

					this.websocket.send(JSON.stringify({
						"message": {
							"id": user.id,
							"player2_id": user.id,
							"player1_selected": false,
							"room_ready": true	
						}
					}));

					this.websocket.onmessage = (event) => {
						const data = JSON.parse(event["data"]);
						this.websocket_queue = data["message"];
					}

					resolve();
					return;
				}

				this.game_objects.find((obj) => obj.id === "player1").pk = user.id;
				
				this.websocket.send(JSON.stringify({
					"message": {
						"id": user.id,
						"player1_id": user.id,
						"player1_selected": true
					}
				}));

			});
		}

		setTimeout(() => {
			reject();
		}, 500000);
	})
}

/**
 * @brief clears all the canvas to get only the background
 */
drawBackground() {
	// Clear the canvas
	this.context.fillStyle = this.background_color;
	this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

	// Draw the center line
	this.context.beginPath();
	this.context.strokeStyle = this.counter.color;
	this.context.lineWidth = "2";
	this.context.moveTo(this.canvas.width / 2, this.canvas.height / 8);
	this.context.lineTo(this.canvas.width / 2, this.canvas.height);
	this.context.moveTo(0, this.canvas.height / 8);
	this.context.lineTo(this.canvas.width, this.canvas.height / 8);
	this.context.closePath();
	this.context.stroke();
}

/**
 * @returns true if game has reached any end condition, false otherwise
 */
isEnd() {
	if (this.counter.time_passed >= this.timeout)
		return true;

	if (this.counter.highest_score >= this.max_score)
		return true;

	return false;
}

/**
 * @brief game loop
 */
gameLoop() {
	let animation;

	const player1 = this.game_objects.find((obj) => obj.id === 'player1'); 
	const player2 = this.game_objects.find((obj) => obj.id === 'player2'); 
	const ball = this.game_objects.find((obj) => obj.id === 'ball'); 
	let message;

	if (this.user_id === player1.pk) {
		message = `"player1_dirY":${player1.dirY},`;
		message += `"player1_x":${player1.x},`;
	} else {
		message = `"player2_dirY":${player2.dirY},`;
		message += `"player2_x":${player2.x},`;
	}
	message += `"ball_x":${ball.x},`;
	message += `"ball_y":${ball.y},`;
	message += `"ball_dirX":${ball.dirX},`;
	message += `"ball_dirY":${ball.dirY},`;
	message += `"ball_speed":${ball.speed}`;

	this.websocket.send(`{"message":{${message}}}`);

	console.log(JSON.stringify(this.websocket_queue));
	if (this.websocket_queue != '') {
		if (this.websocket_queue.player1_dirY) player1.dirY = this.websocket_queue.player1_dirY;
		if (this.websocket_queue.player2_dirY) player2.dirY = this.websocket_queue.player2_dirY;

		if (this.websocket_queue.player1_y) player1.y = this.websocket_queue.player1_y;
		if (this.websocket_queue.player2_y) player2.y = this.websocket_queue.player2_y;

		if (this.websocket_queue.ball_x) ball.x = (ball.x + this.websocket_queue.ball_x) / 2
		if (this.websocket_queue.ball_y) ball.y = (ball.y + this.websocket_queue.ball_y) / 2
		if (this.websocket_queue.ball_dirX) ball.dirX = (ball.dirX + this.websocket_queue.ball_dirX) / 2
		if (this.websocket_queue.ball_dirY) ball.dirY = (ball.dirY + this.websocket_queue.ball_dirY) / 2
		if (this.websocket_queue.ball_speed) ball.speed = (ball.speed + this.websocket_queue.ball_speed) / 2

		this.websocket_queue = '';
	}

	for (let i in this.game_objects)
		this.game_objects[i].update(this.game_objects);

	this.drawBackground();
	for (let i in this.game_objects)
		this.game_objects[i].render();

	if (!this.isEnd())
		animation = window.requestAnimationFrame(this.gameLoop.bind(this));
	else {
		this.websocket.close();
		console.log(JSON.stringify(this)); // TODO: exportar info de la partida
		window.cancelAnimationFrame(animation);
	}
}

setStartTime(time) {
	this.game_objects.find((obj) => obj.id === "counter").setStartTime(time);
}

toJSON() {
	// TODO: definir bien el JSON que posteriormente se serializara
	// TODO: id del torneo
	// TODO: bool de si esta dentro de un torneo
	return {
		player1_pk: this.game_objects.find((obj) => obj.id === "player1").pk,
		player1_score: this.counter.player1_score,

		player2_pk: this.game_objects.find((obj) => obj.id === "player2").pk,
		player2_score: this.counter.player2_score,

		game_time: this.counter.time_passed
	}
}
}

export {Game}

	// getUsers(localStorage.getItem("token")).then(user => {}) // TODO: para setear las salas
function tmp_for_message_from_server(event) {
	const data = JSON.parse(event["data"]);
	let room_id; // TODO: quizas vaya en this

	switch(data["type"]) {
	case "room.created":
		room_id = data["message"]["room_id"]
		break;
	case "game.start":
		break;
	default:
	}
}
