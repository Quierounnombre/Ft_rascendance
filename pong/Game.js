import { CanvasObject } from "./CanvasObject.js";
import { Counter } from "./Counter.js";
import { Ball } from "./Ball.js";
import { Player } from "./Player.js";
"use strict";

class Game {
/**
 * @param {JSON array} objs array generated by parsing the JSON with the config file
 */
constructor(objs) {	
	this.canvas = document.getElementById("pong"); // TODO: pong o game? elegir nombre
	this.context = this.canvas.getContext("2d");
	this.game_objects = [];

	// TODO: valores por defecto a los valores que extraerÃ¡ de config
	this.background_color = "black";
	this.object_color = "white";
	this.timeout = 180000;
	this.max_score = 5;

	for (let i in objs) {
		switch (objs[i].type) {
		case "config":
			for(let j in objs[i])
				this[j] = objs[i][j];
			break;
		case "player":
			this.game_objects.push(new Player(objs[i], this.canvas, this.context));
			break;
		case "ball":
			this.game_objects.push(new Ball(objs[i], this.canvas, this.context));
			break;
		case "counter":
			this.game_objects.push(new Counter(objs[i], this.canvas, this.context));
			break;
		default:
			this.game_objects.push(new CanvasObject(objs[i], this.canvas, this.context));
		}
	}

	this.counter = this.game_objects.filter((obj) => obj.type === "counter");
	this.counter.timeout = this.timeout;

	this.game_objects.filter((obj) => obj.type === "ball")
	            .forEach((obj) => obj.counter = this.counter);

	// TODO: sacar color jugadores 1 y 2. Que cada jugador pueda jugar con los colores que desee
	// esto no iria en el json que genera la sala?
}

/**
 * @brief clears all the canvas to get only the background
 */
drawBackground() {
	// Clear the canvas
	this.context.fillStyle = this.background_color;
	this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

	// Draw the center line
	this.context.beginPath();
	this.context.strokeStyle = this.object_color;
	this.context.lineWidth = "1";
	this.context.moveTo(this.canvas.width / 2, this.canvas.height / 8);
	this.context.lineTo(this.canvas.width / 2, this.canvas.height);
	this.context.moveTo(0, this.canvas.height / 8);
	this.context.lineTo(this.canvas.width, this.canvas.height / 8);
	this.context.closePath();
	this.context.stroke();
}

/**
 * @returns true if game has reached any end condition, false otherwise
 */
isEnd() {
	if (this.counter.time_passed >= this.timeout)
		return true;

	if (this.counter.highest_score >= this.max_score)
		return true;

	return false;
}

/**
 * @brief game loop
 */
gameLoop() {
	this.drawBackground();

	for (let i in this.game_objects) {
		this.game_objects[i].update(this.game_objects);
		this.game_objects[i].render();
		this.game_objects[i].renderHitBox();
	}

	if (!this.isEnd())
		window.requestAnimationFrame(this.gameLoop.bind(this));
}
}

export {Game}
